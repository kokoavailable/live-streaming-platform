# 1. 베이스 이미지( 컴파일러 및 관련 도구 포함), 
# 알리아스를 통해 향후 스테이지에서 이름으로 참조할 수 있다.
# 2. 작업 디렉토리를 설정해(도커 컨테이너 안) 이후 명령이 해당 디렉토리에서 실행된다.
# 3. 프록시 설정을 통해 의존성을 안정적이고 빠르게 다운로드 할 수 있도록 한다. 
# 고 프록시는 고 모듈의 의존성을 다운로드할 때, 중간 캐시 역할을해 성능을 개선한다.
# 일반적으로는 필요 모듈을 원본 소스에서 직접 가져오나(github 의 제한과 네트워크 지연을 따름)
# 프록시는 종종 인기 있는 모듈을 미리 캐시해 두므로 다운이 빠르고 안정적이다.
# 4. 소스 파일들을(도커 파일이 있는 디렉 토리를 기준으로 상대 경로로 지정) 
# 마지막 인자인 대상 디렉토리로 복사한다.(이 경우엔 작업 디렉토리(도커 컨테이너 안))
# 5. go.mod 를 통해 정의된 의존성을 다운로드해 컨테이너에 저장한다. 다운로드 된 의존성은 
# $GOPATH/pkg/mod에 저장된다. 의존성을 먼저 카피하는 과정을 거치지 않으면, main.go의 한줄이 수정되더라도 빌드단계가 다시 실행된다.
# 6. 도커는 캐시를 단계별로 저장한다. 즉 의존성 단계를 먼저 처리하고 나중에 소스 코드를 복사해 빌드 시간을 절약한다.
# 7. C 라이브러리를 비활성화해 정적 바이너리로 애플리케이션을 빌드한다. 리눅스 환경에서 실행 가능한 바이너리를 빌드한다.
# 빌드된 바이너리와 패키지를 구별하기 위한 추가 접미사. cgo라는 접미사를 추가해 cgo 설정 여부를 명시적으로 구별한다.
# -a 옵션은 로컬에서 의존성 패키지 캐시를 무시하고 모든 패키지를 다시 컴파일 해 클린 빌드를 보장한다.
# 결과물을 livego 라는 파일 이름으로 생성

FROM golang:latest as builder
WORKDIR /app
ENV GOPROXY https://goproxy.io
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o livego .


# 이전 빌드 스테이지에서 생성된 결과물(바이너리. livego)을 가져오는 작업을 수행한다.
# <소스경로> <대상 경로>
# 도커의 멀티스테이지 빌드는 빌드환경과 실행 환경을 완전히 분리한다. 
# 첫번째 스테이지에서는 고 컴파일러와 빌드 도구가 포함된 환경에서 실행파일 생성한 무거운 환경
# 두번쨰 스테이지에서는 경량 알파인 이미지를 사용해 실행 파일만 포함한 이미지를 생성한다.
# 이작업이 없으면 실행파일이 최종 이미지에 포함되지 않으므로 컨테이너가 정상적으로 실행되지 않는다.
# alpine은 경량 리눅스 이미지를 기반으로 한다
# 컨테이너가 시작되면 /app/livego 실행 파일을 실행한다.
# 첫번쨰 스테이지와 두번쨰 스테이지의 /app디렉토리는 완전히 별개이다. 각 스테이지는 독립적 파일 시스템을 가지며 서로의 파일 시스템에 직접 접근할 수 없다.
# 첫번째 스테이지와 두번째 스테이지를 나누는 기준은 FROM 명령어가 된다. 
# 첫번쨰 스테이지는 최종 이미지에 포함되지 않고 두번째 스테이지만 최종 이미지로 사용된다. 
FROM alpine:latest
RUN mkdir -p /app/config
WORKDIR /app
ENV RTMP_PORT 1935
ENV HTTP_FLV_PORT 7001
ENV HLS_PORT 7002
ENV HTTP_OPERATION_PORT 8090
COPY --from=builder /app/livego .
EXPOSE ${RTMP_PORT}
EXPOSE ${HTTP_FLV_PORT}
EXPOSE ${HLS_PORT}
EXPOSE ${HTTP_OPERATION_PORT}
ENTRYPOINT ["./livego"]